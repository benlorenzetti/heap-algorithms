#include <iostream>
#include <string>
#include <assert.h>
using namespace std;

class Decimal {
 public:
  string str;
  size_t dpt;
  Decimal();
  Decimal(const string &);
  int integral_trunc();
  int fraction_trunc();
  void integral_add(const Decimal &, int);
  void fraction_add(const Decimal &, int);
};
bool is_zero(const Decimal &);
ostream &operator<<(ostream &os, Decimal const &);
Decimal operator+(const Decimal &, const Decimal &);

Decimal::Decimal() { str.clear(), dpt=string::npos; }
Decimal::Decimal(const string &s) {
  str = s;
  dpt = s.find('.');
}

ostream &operator<<(ostream &os, Decimal const &d) {
  return os << d.str;
}

Decimal operator+(const Decimal &a, const Decimal &b) {
  Decimal d;

  return move(d);
}

bool is_zero(const Decimal &d) {
  for(int i=0; i<d.str.size(); i++)
    if(d.str[i] != '0' || d.str[i] != '.')
      return false;
  return true;
}

int Decimal::integral_trunc() {
  assert(!is_zero(*this));
  size_t trunc = 0;
  while(str[trunc] == '0' && str[trunc] != '.')
    ++trunc;
  str = str.substr(trunc, str.size() - trunc);
  if(dpt != string::npos)
    dpt -= trunc;
  return dpt - 1;
}

int Decimal::fraction_trunc() {
  if(dpt == string::npos)
    return 0;
  while(str[str.size()-1] == '0' && str[str.size()-1] != '.')
    str.pop_back();
  return str.size() - dpt;
}

void Decimal::integral_add(const Decimal &d, int E) {
  assert(string::npos == d.str.find('.') && E >= 0);
  int op1_len = (str.size() - 1) - dpt;
  int op2_len = d.str.size() + E;
  int proplen = max(op1_len, op2_len) + 1;
}
